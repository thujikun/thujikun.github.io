<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Thujikun blog]]></title>
  <link href="http:// thujikun.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http:// thujikun.github.io/"/>
  <updated>2013-12-14T10:33:29+09:00</updated>
  <id>http:// thujikun.github.io/</id>
  <author>
    <name><![CDATA[Ryosuke Tsuji]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ちょっと未来のJavaScript]]></title>
    <link href="http:// thujikun.github.io/blog/2013/12/14/ie/"/>
    <updated>2013-12-14T02:00:03+09:00</updated>
    <id>http:// thujikun.github.io/blog/2013/12/14/ie</id>
    <content type="html"><![CDATA[<p>来年遂にXPが逝去されるということで、IE9以降のシェアが飛躍的に伸びることを祈りつつ、IE9以降でJavaScriptでできるようになることを気がつく限りまとめてみました。</p>

<h2>DOM</h2>

<h3>addEventListener / removeEventListener</h3>

<p>イベントを登録/削除するためのメソッド。IE8まではattachEventとdetachEventという似たような、でも割と細かいところで動きが違うメソッドを使う必要があったが、IE9から標準のaddEventListenerがサポートされている。<br/>
※ jQueryのon/offとかbind/unbindとだいたい同じ。<br/>
※ 第3引数はuseCaptureといって、trueにするとイベント伝播を上位のDOMから発生させることができる。まあ使うことないけど。<br/>
※ <a href="https://developer.mozilla.org/ja/docs/Web/API/EventTarget.addEventListener">addEventListener</a>, <a href="https://developer.mozilla.org/ja/docs/Web/API/EventTarget.removeEventListener">removeEventListener</a>
```javascript</p>

<pre><code>function onClickFunction(e) {
    //クリック時の処理
}
// クリックイベント設定
document.getElementById('hoge').addEventListener('click', onClickFunction, false);

// クリックイベント削除
document.getElementById('hoge').removeEventListener('click', onClickFunction, false);
</code></pre>

<p>```</p>

<h3>createEvent / dispatchEvent</h3>

<p>イベントを作成/発火するためのメソッド。IE8まではcreateEventObjectとfireEventというこれまた似たような、でもやっぱり色々動きが異なるメソッドがあった。<br/>
※ jQueryの$.eventとかtriggerとだいたい同じ。<br/>
※ <a href="https://developer.mozilla.org/ja/docs/DOM/document.createEvent">createEvent</a>, <a href="https://developer.mozilla.org/ja/docs/Web/API/EventTarget.dispatchEvent">dispatchEvent</a>
```javascript</p>

<pre><code>// イベントオブジェクト作成
// 引数にはイベント種別を渡す。
var evt = document.createEvent('MouseEvents');

// イベントオブジェクト初期化
// 引数の内容はhttps://developer.mozilla.org/ja/docs/Web/API/event.initMouseEventを参照。
// マウス座標とかctrlキーが押されてるかどうかなど色々指定可能。
evt.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);

// イベント発火
document.getElementById('hoge').dispatchEvent(evt);
</code></pre>

<p>```</p>

<h3>Composition Events</h3>

<p>composition Eventsは文字の変換イベントを取得できるメソッドです。<br/>
これまではFFにも対応したければsetIntervalで入力中にテキストフィールドを監視する必要があったのが、これを使えば解消することができます。<br/>
まあIE系ならkeydown + setTimeoutでもいいし、FFならinputイベント使えばいいって話もあるけど。<br/>
※ compositionstartイベントとcompositionupdateイベントは同時に発火するが、compositionupdateイベントとcompositionendイベントは同時に発火しない。<br/>
※ <a href="https://developer.mozilla.org/ja/docs/DOM/CompositionEvent">CompositionEvent</a>
```javascript</p>

<pre><code>var textElement = document.getElementById('hoge');

// テキスト変換開始時イベント監視
textxElement.addEventListener('compositionstart', function(e) {
    //変換開始時処理
}, false);

// テキスト変換中イベント監視
textxElement.addEventListener('compositionupdate', function(e) {
    //変換中処理
}, false);

// テキスト変換完了時イベント監視
textxElement.addEventListener('compositionend', function(e) {
    //変換完了時処理
}, false);
</code></pre>

<p>```</p>

<h3>Mutation Events</h3>

<p>DOMの追加/変更/削除などDOMの状態監視ができるイベント。類似メソッドは今までなかったのでかなり画期的なんじゃないかと思う。Angularの処理を強引にjQueryで補足したいときとかに使えるかもね。<br/>
※ 多用すると処理が追えなくなり可能性あり。<br/>
※ IE9ではDOMNodeInsertedが動かないらしい。<br/>
※ パフォーマンスの関係でMutation Eventsは非推奨になり、最新仕様はMutation Observerになっている。そのためMutation EventsはPolyfillとして用いるべし。<br/>
※ <a href="https://developer.mozilla.org/ja/docs/Web/Guide/API/DOM/Events/Mutation_events">Mutation Events</a>, <a href="https://developer.mozilla.org/ja/docs/Web/API/MutationObserver">Mutation Observer</a>
```</p>

<pre><code>// エレメントの属性の変更を監視
document.getElementById('hoge').addEventListener('DOMAttrModified', function(e) {
    // 属性変更時処理
    console.log('変更された！');
});

document.getElementById('hoge').style.backgroundColor = '#000';
// -&gt; 変更された！
</code></pre>

<p>```</p>

<pre><code>あれ、数日前に試したときは動作したのになぜか今動かない。。。とりあえず先に進もう。  
</code></pre>

<h3>DOMContentLoaded Event</h3>

<p>DOMの読み込みを待ち合わせるイベント。<br/>
※ $(document).ready(function(){})とか$(function(){})と同じ。IE9以降なら内部的にこれが使われてる。<br/>
※ <a href="https://developer.mozilla.org/ja/docs/Web/Reference/Events/DOMContentLoaded">DOMContentLoaded</a>
```javascript</p>

<pre><code>document.addEventListener('DOMContentLoaded', function() {
    // DOM読み込み時処理
}, false);
</code></pre>

<p>```</p>

<h3>querySelector / querySelectorAll</h3>

<p>CSSのselectorでDOM探索ができるメソッド。完全にjQuery感覚で使えます。まあgetElementByIdとかgetElementsByClassNameとか別のが使える場合はそっち使った方が速いです。<br/>
※ <a href="https://developer.mozilla.org/ja/docs/Web/API/document.querySelectorAll">querySelectorAll</a>
<code>
var list = document.querySelectorAll('ul li');
</code></p>

<p>classListはIE10から、datasetとはIE11からの実装のようです。。。</p>

<h2>ECMA Script 5</h2>

<h3>Array</h3>

<pre><code>Array型の追加メソッドはunderscoreとか使ってる人ならピンとくるはず。  
</code></pre>

<ul>
<li><p>forEach<br/>
  引数に関数をとり、値とインデックスがループでまわって引数に入ってくる。ようはfor文回すのに、iとかlengthとか必要ないし、 ループ内スコープの変数が使えるってこと。<br/>
  ※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">forEach</a><br/>
```javascript
  var arr = [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;, &rsquo;d', &lsquo;e&rsquo;];</p>

<p>  arr.forEach(function(value, index) {
      // function内部なので、スコープがループの中で閉じる
      var foo = &lsquo;bar&rsquo;;</p>

<pre><code>  console.log(value, index);
  // -&gt; 値とインデックスがコンソールに出力される
</code></pre>

<p>  });
```</p></li>
<li><p>filter
  配列の中から指定した条件を満たすものだけを取り出して新たな配列を作成することができる。非破壊的メソッド。<br/>
  ※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a><br/>
```javascript
  var arr = [2, 45, 21, 67, 32, 2, 43];</p>

<p>  arr.filter(function(value, index) {
      // 偶数のものだけ取り出す。
      return value % 2 === 0;
  });
```</p></li>
<li><p>indexOf
  配列を指定された値で検索するメソッド。返却値は見つかった最初のインデックスで、ない場合は-1が返る。<br/>
  検索を始めるインデックスを第二引数で指定することも可能。<br/>
  ※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">indexOf</a>
```javascript
  var arr = [&lsquo;abc&rsquo;, &lsquo;def&rsquo;, &lsquo;ghi&rsquo;, &lsquo;jkl&rsquo;];</p>

<p>  console.log(arr.indexOf(&lsquo;def&rsquo;));
  // &ndash;> 1
  console.log(arr.indexOf(&lsquo;mno&rsquo;));
  // &ndash;> -1
```</p></li>
<li><p>some
  配列の各要素に対してテストを実行し、一つでもテストに合格する要素があればtrueを返し、一つもなければfalseを返す。<br/>
  ※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/some">some</a>
```javascript
  var arr = [2, 45, 21, 67, 32, 2, 43];</p>

<p>  // 60以上の値があるかどうか判定
  console.log(arr.some(function(value) {
      return 60 &lt; value;
  }));
  // &ndash;> true</p>

<p>  // 70以上の値があるかどうか判定
  console.log(arr.some(function(value) {
      return 70 &lt; value;
  }));
  // &ndash;> false
```</p></li>
<li><p>every
  配列の各要素に対してテストを実行し、全要素がテストに合格であればtrueを返し、一つでも欠ければfalseを返す。<br/>
  ※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/every">every</a>
```javascript
  var arr = [2, 45, 21, 67, 32, 2, 43];</p>

<p>  // 全ての値が1以上かどうか判定
  console.log(arr.every(function(value) {
      return 1 &lt; value;
  }));
  // &ndash;> true</p>

<p>  // 全ての値が5以上かどうか判定
  console.log(arr.every(function(value) {
      return 5 &lt; value;
  }));
  // &ndash;> false
```</p></li>
<li><p>map
  配列の各要素に対して処理を行い、その結果からなる新しい配列を生成する。非破壊的メソッド<br/>
  ※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a>
```javascript
  var arr = [2, 45, 21, 67, 32, 2, 43];</p>

<p>  // 全ての値が1以上かどうか判定
  console.log(arr.map(function(value) {
      return value * 10;
  }));
  // &ndash;> [20, 450, 210, 670, 320, 20, 430]
```</p></li>
<li><p>reduce
  配列の隣り合う値を左から順に呼び出し、その結果から単一の値をつくる。<br/>
  ※ 右から実行する<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">reduceRight</a>もある。<br/>
  ※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">reduce</a>
```javascript
  var arr = [2, 45, 21, 67, 32, 2, 43];</p>

<p>  // 全ての値が1以上かどうか判定
  console.log(arr.reduce(function(value1, value2) {
      console.log(arguments);
      return value1 + value2;
  }));
  // &ndash;> 212
```</p></li>
</ul>


<h3>Object</h3>

<ul>
<li>defineProperty / defineProperties<br/>
  Objectにプロパティを追加するメソッド。Object.hoge = function(){};の形で書くのに比べ、writable属性、enumerable属性、configurable属性の設定ができたり、アクセサ（配列のlengthみたいなやつ）がつくれたりする。

<ul>
<li>writable: 上書き可能かどうか</li>
<li>enumerable: for inループなどのObjectのプロパティ列挙時に表示されるかどうか。</li>
<li>configurable: プロパティの設定を変更することができるかどうか。</li>
<li>get: プロパティのゲッターとなるメソッド。(アクセサの場合のみ)</li>
<li>set: プロパティのセッターとなるメソッド。(アクセサの場合のみ)<br/>
※ 個人的にはprototype拡張の際によく使うが、様々な用途で使えるとは思う。<br/>
※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">defineProperty</a>
```
var MyClass = function() {
  this.members = {};
};</li>
</ul>


<p>  // メンバーを登録するsetMemberメソッドを作成
  Object.defineProperty(MyClass.prototype, &lsquo;setMember&rsquo;, {
      writable: false,
      enumeable: false,
      configurable: false,
      value: function(id, name) {
          this.members[id] = name;
      }
  });</p>

<p>  // メンバーを取得するgetMemberメソッドを作成
  Object.defineProperty(MyClass.prototype, &lsquo;getMember&rsquo;, {
      writable: false,
      enumeable: false,
      configurable: false,
      value: function(id) {
          return this.members[id];
      }
  });</p>

<p>  // 現在のメンバー数を返却するcountアクセサを追加。値を指定された場合は何もしない。
  Object.defineProperty(MyClass.prototype, &lsquo;count&rsquo;, {
      get: function() {
          var count = 0,
              p;</p>

<pre><code>      for(p in this.members) {
          count++;
      }

      return count;
  },
  set: function() {}
</code></pre>

<p>  });</p>

<p>  var myClass = new MyClass();</p>

<p>  myClass.setMember(&lsquo;foo&rsquo;, &lsquo;bar&rsquo;);
  myClass.setMember(&lsquo;hoge&rsquo;, &lsquo;hogehoge&rsquo;);
  console.log(myClass.getMember(&lsquo;foo&rsquo;));
  // &ndash;> &lsquo;bar&rsquo;</p>

<p>  console.log(myClass.count);
  // &ndash;> 2</p>

<p>  // setメソッドは何もしないので値を登録しても値は変化しない。
  myClass.count = 10;
  console.log(myClass.count);
  // &ndash;> 2
```</p></li>
<li>create<br/>
指定したオブジェクトのプロトタイプ及び、プロパティを持つオブジェクトを生成する。簡単に既存のオブジェクトを継承して、新しいプロトタイプも持つオブジェクトがつくれる。<br/>
definePropertyと同様に、各属性の設定や、アクセサもつくれる。<br/>
※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/create">create</a>
```
  // 通常の配列を追加
  var arr = [&lsquo;a&rsquo;, 232, &lsquo;b&rsquo;, true, 1111];
  // 配列を拡張して、0から数えたlengthプロパティを新たに追加。
  var customArr = Object.create(arr, {
      lengthFromZero: {
          get: function() {
              return this.length &ndash; 1;
          },
          set: function() {}
      }
  });</li>
</ul>


<p>console.log(customArr.lengthFromZero);
<code>
* getOwnPropertyNames  
enumerable属性に関わらず、オブジェクトのプロパティを配列で返却する。  
※ [getOwnPropertyNames](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)
</code>
console.log(Object.getOwnPropertyNames(Array.prototype));
// &ndash;> [&ldquo;length&rdquo;, &ldquo;constructor&rdquo;, &ldquo;toString&rdquo;, &ldquo;toLocaleString&rdquo;, &ldquo;join&rdquo;, &ldquo;pop&rdquo;, &ldquo;push&rdquo;, &ldquo;concat&rdquo;, &ldquo;reverse&rdquo;, &ldquo;shift&rdquo;, &ldquo;unshift&rdquo;, &ldquo;slice&rdquo;, &ldquo;splice&rdquo;, &ldquo;sort&rdquo;, &ldquo;filter&rdquo;, &ldquo;forEach&rdquo;, &ldquo;some&rdquo;, &ldquo;every&rdquo;, &ldquo;map&rdquo;, &ldquo;indexOf&rdquo;, &ldquo;lastIndexOf&rdquo;, &ldquo;reduce&rdquo;, &ldquo;reduceRight&rdquo;]
<code>
* keys  
オブジェクトの列挙可能なプロパティを配列で返却する。for-inループと違い、プロトタイプのプロパティはとってこない。   
※ https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
</code>
var obj = {</p>

<pre><code>foo: 'bar',
hoge: 'hogehoge'
</code></pre>

<p>};
console.log(Object.keys(obj));
// &ndash;> [&lsquo;foo&rsquo;, &lsquo;hoge&rsquo;]
<code>
* freeze  
オブジェクトを凍結する。具体的にはプロパティの追加/編集/削除、設定変更を不可能にする。プロパティがObjectの場合、その中身までは凍結できない。  
※ [freeze](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)
</code>
var obj = {</p>

<pre><code>foo: 'bar',
hoge: 'hogehoge',
list: {
    foofoo: 'barbar'
}
</code></pre>

<p>};</p>

<p>// オブジェクトを凍結
Object.freeze(obj);</p>

<p>// obj.list.foofooのみ編集可能。
obj.hoge = &lsquo;hogehogehoge&rsquo;;
obj.name = &lsquo;taro&rsquo;;
obj.list.foofoo = &lsquo;barbarbarbar&rsquo;;
console.log(obj);
```</p>

<h3>Function</h3>

<ul>
<li>bind
Functionのthisを引数のオブジェクトでバインドする。apply/callと違ってその場でfunctionコールせず、thisでbindされたfunctionオブジェクトを返却してくれる。<br/>
※ $.proxyとか_.bindと同じ。<br/>
※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a>
```
function foo() {
  console.log(this);
}</li>
</ul>


<p>var bar = foo.bind({hoge: &lsquo;hogehoge&rsquo;});</p>

<p>bar();
// &ndash;> {hoge: &lsquo;hogehoge&rsquo;}
```</p>

<h3>String</h3>

<ul>
<li>trim / trimRight / trimLeft<br/>
念願のtrimがようやくjsに。文字列の前後の空白を削除する。非破壊的メソッド<br/>
※ 驚くべきことに全角空白にも対応している！！！<br/>
※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/trim">trim</a>
```
var foo = &lsquo;　　　   bar   　　　&rsquo;;</li>
</ul>


<p>console.log(foo.trim());
// &ndash;> bar
```</p>

<h3>Date</h3>

<ul>
<li>now<br/>
UTC（協定世界時）での1970年1月1日00時00分00秒から現在までの経過ミリ秒を数値で取得するメソッド。new Date().getTime()と同じ。相違点はスピード。<br/>
※ <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Date/now">now</a>
<code>javascript
console.log(Date.now());
</code></li>
</ul>


<h2>IE8とどうしたもまだ付き合わなきゃいけない方へ</h2>

<p>es5のshimを使ってくださってる方がいるので、これを入れると上記のメソッド達はだいたい使えます。<br/>
<a href="https://github.com/kriskowal/es5-shim  ">https://github.com/kriskowal/es5-shim  </a>
DOM系のやつもそれぞれshimを作ってる方がいたり、あとは自分でpolyfill作ってしまってもよいかもですね。</p>

<h2>まとめ的な</h2>

<p>HTML5とかCSS3はまだだいぶ弱いですが、DOM系とES5系でそれなりに強化されるので、小さいサイトの制作であればjQueryを使わない選択肢があってもいいんじゃないかなーと思ってます。<br/>
まあこのへんが前からサポートされてるスマートフォン向けサイトでも、Zeptoすらあまり使われずjQueryが当たり前に使われてる現状を考えると難しそうですが。。。<br/>
ネイティブのjsでかかれたプラグインが充実してくれば変わってくるのかな。</p>

<h2>HTML5</h2>

<p>HTML5のAPIについてはいろんなところにサンプルあるので詳細は割愛しますー。<br/>
やはりCanvasとSVGが目立つところですかね。</p>

<h3>canvas</h3>

<h3>SVG</h3>

<h3>Section Elements</h3>

<h3>Geolocation</h3>

<h3>Video(H.264) not Mpeg4, WebM</h3>

<h3>Audio(AAC and MP3)</h3>

<h2>IE10+ (HTML5)</h2>

<p>ちゃんと洗い出してないのでこれだけではないと思いますが、IE10まで移行できれば強力なAPIが目白押しですね。</p>

<h3>History API</h3>

<h3>HTML5 Validation</h3>

<h3>websocket</h3>

<h3>input[type=xxx]</h3>

<h3>Field validation</h3>

<h3>Pointer Events</h3>

<h3>XHR2</h3>

<h3>Drag and Drop</h3>

<h3>Native Binary Data</h3>

<h3>Web Workers</h3>

<h3>CORS</h3>

<h3>Sandboxed iframe</h3>

<h3>Application cache</h3>

<h3>Indexed DB</h3>

<h3>File API</h3>

<h3>pagevisibility API</h3>

<h2>さらにES6も使いたい方へ</h2>

<p>ES6では、定数、ブロックスコープ変数、Class、Module、Promise、generator、iterator、配列内包記法、arrow function、Map、WeakMap、Set、of loopなどなどまさに夢のようなAPI達がこれでもかと使うことができます。現在の実装状況は下記を参照すると良いです。<br/>
<a href="http://kangax.github.io/es5-compat-table/es6/  ">http://kangax.github.io/es5-compat-table/es6/  </a>
見ていただければわかりますが、FFの実装が最も進んでいます。Chromeも頑張ってはいますが、FlagをONにしなきゃいけないので非現実的ですね。<br/>
まとめると以下の方法が現在ES6を使うための手法です。<br/>
* traceur-compilerを使う。<br/>
<a href="https://github.com/google/traceur-compiler">https://github.com/google/traceur-compiler</a></p>

<p>主要な機能は大体使えます。具体的な使い方はこんな感じ。<br/>
```html
<html>
  <body></p>

<pre><code>&lt;script src="https://traceur-compiler.googlecode.com/git/bin/traceur.js" 
    type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="https://traceur-compiler.googlecode.com/git/src/bootstrap.js"
    type="text/javascript"&gt;&lt;/script&gt;
&lt;script type="text/traceur"&gt;
  class Greeter {
    constructor(message) {
      this.message = message;
    }

    greet() {
      let element = document.querySelector('#message');
      element.innerHTML = this.message;
    }
  };

  let greeter = new Greeter('Hello, world!');
  greeter.greet();
&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
<code>
* node.jsを使う。  
Gruntなどサーバを立てる用途でなくてもnodeを使う機会は確実に増えている今日この頃、これを使わない手はありません。  
node起動時に--harmonyオプションをつけるか、Gruntなど内部的にNodeを呼ぶやつで使う場合はpackage.jsonをちょっと工夫してやるとES6の機能が開放されます。  
</code>
{
  &ldquo;scripts&rdquo;: {</p>

<pre><code>"start": "node --harmony ./node_modules/.bin/grunt start"
</code></pre>

<p>  }
}
```
* FirefoxOSアプリ開発を行う。<br/>
上記でも言ったようにFirefoxの実装は最も進んでいる状況なので、FirefoxOS向けアプリ開発ではES6の機能がガンガン使えます。<br/>
本来Web標準で作れることのメリットであるクロスプラットフォームの互換性は失われますが、そんなものは現場からすると初めから幻想なのでムシムシ。<br/>
* RhinoもしくはNashornを使う。<br/>
これはだいぶマニアックな方法ですがMozillaがJVM上でjavascriptで書いたコードをJavaに変換して実行するライブラリを出しています。<br/>
MozillaということはFirefoxと大体同じ実装状況だと言えるので、ES6の機能もだいぶサポートされています。<br/>
Java7までがRhino、Java8からがNashornになります。<br/>
ちなみにClosure CompilerはRhinoを使ってますね。</p>

<p>というわけでここまで読んでいただいてありがとうございましたー！</p>
]]></content>
  </entry>
  
</feed>
